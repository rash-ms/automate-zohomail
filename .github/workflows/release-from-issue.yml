name: Build release from Issue Form

on:
  issues:
    types: [opened, edited, labeled]

permissions:
  contents: write
  pull-requests: write
  issues: read

jobs:
  build:
    if: contains(github.event.issue.labels.*.name, 'release-request')
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Configure git
        run: |
          git config user.name  "release-bot"
          git config user.email "release-bot@users.noreply.github.com"

      - name: Use gh (preinstalled)
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh --version
          gh pr list --author "$GITHUB_ACTOR" --base stage --state open

      - name: Read and validate form values (fail if missing)
        id: form
        env:
          REPO: ${{ github.repository }}
          ISSUE: ${{ github.event.issue.number }}
        run: |
          # Write the exact Issue Form body
          cat > body.txt <<'EOF'
          ${{ github.event.issue.body }}
          EOF
      
          # Helper: capture the first non-empty line after a header whose text STARTS with $1
          get_field () {
            awk -v prefix="$1" '
              BEGIN{flag=0}
              # Detect headers that start with "### "
              /^###[[:space:]]/{
                # Strip the leading "### " and any leading spaces
                line=$0
                sub(/^###[[:space:]]*/,"",line)
                # If the header begins with the prefix (literal, not regex), start capturing
                if (index(line, prefix)==1) { flag=1; next } else { flag=0 }
              }
              # While in the right section, print lines until the next header
              flag { print }
            ' body.txt | sed '/^[[:space:]]*$/d' | head -n 1 | xargs
          }
      
          # Same idea, but return the whole section for parsing EXTRA PRs
          get_section () {
            awk -v prefix="$1" '
              BEGIN{flag=0}
              /^###[[:space:]]/{
                line=$0
                sub(/^###[[:space:]]*/,"",line)
                if (index(line, prefix)==1) { flag=1; next } else { flag=0 }
              }
              flag { print }
            ' body.txt
          }
      
          # Read fields by their header PREFIX (ignore any hints in parentheses)
          GH_USERNAME=$(get_field "Your GitHub username (exact)")
          BASE=$(get_field "Base branch PRs target")
          STATE=$(get_field "PR state to include")
          LABEL_SUFFIX=$(get_field "Your unique label suffix")
      
          # Optional list of PRs/URLs
          EXTRA=$(get_section "Extra PR numbers or URLs" \
            | sed 's/.*pull\///' \
            | sed 's/[^0-9].*$//' \
            | grep -E '^[0-9]+$' || true)
      
          # Fail if any required field is missing
          for var in GH_USERNAME BASE STATE LABEL_SUFFIX; do
            eval v=\$$var
            if [ -z "$v" ]; then
              echo "::error::$var is required in the issue form"; exit 1
            fi
          done
      
          # Opener must match the GH username
          OPENER="${{ github.event.issue.user.login }}"
          if [ "$OPENER" != "$GH_USERNAME" ]; then
            echo "::error::Issue opener ($OPENER) must match GH username ($GH_USERNAME)"; exit 1
          fi
      
          READY_LABEL="ready-for-prod-$LABEL_SUFFIX"
          {
            echo "GH_USERNAME=$GH_USERNAME"
            echo "BASE=$BASE"
            echo "STATE=$STATE"
            echo "READY_LABEL=$READY_LABEL"
            echo "EXTRA=$(echo "$EXTRA" | paste -sd, -)"
          } >> "$GITHUB_OUTPUT"

      - name: Find matching PRs by username+base+unique label
        id: find
        env:
          GH_TOKEN: ${{ github.token }}
          GH_USERNAME: ${{ steps.form.outputs.GH_USERNAME }}
          BASE: ${{ steps.form.outputs.BASE }}
          STATE: ${{ steps.form.outputs.STATE }}
          READY_LABEL: ${{ steps.form.outputs.READY_LABEL }}
        run: |
          # Build gh filters
          ARGS=(--author "$GH_USERNAME" --base "$BASE" --state "$STATE" --label "$READY_LABEL")

          PRS=$(gh pr list "${ARGS[@]}" --json number,title,url \
              --jq 'map(.number)|join(",")')
          if [ -z "$PRS" ]; then
            echo "::error::No PRs found for author=$GH_USERNAME base=$BASE state=$STATE label=$READY_LABEL"; exit 1
          fi
          echo "PRS=$PRS" >> $GITHUB_OUTPUT
          echo "Found PRs: $PRS"

      - name: Combine with any extra PRs
        id: combine
        run: |
          A="${{ steps.find.outputs.PRS }}"
          B="${{ steps.form.outputs.EXTRA }}"
          LIST=$(printf "%s\n%s\n" "$A" "$B" | tr ',' '\n' | grep -E '^[0-9]+$' | sort -u | paste -sd, -)
          if [ -z "$LIST" ]; then
            echo "::error::No PRs to include after combining."; exit 1
          fi
          echo "PR_LIST=$LIST" >> $GITHUB_OUTPUT
          echo "Including PRs: $LIST"

      - name: Create release branch from main
        id: mk
        run: |
          git fetch origin main
          # Unique name: date+time (to the second) + issue + run id
          BR="release/$(date +%Y-%m-%d-%H%M%S)-${{ github.event.issue.number }}-${{ github.run_id }}"
          git switch -c "$BR" origin/main
          echo "BRANCH=$BR" >> "$GITHUB_OUTPUT"

      - name: Merge selected PRs (squash commits)
        env:
          GH_TOKEN: ${{ github.token }}
          PRS: ${{ steps.combine.outputs.PR_LIST }}
        run: |
          IFS=, read -ra arr <<< "$PRS"
          for PR in "${arr[@]}"; do
            PR=$(echo "$PR" | xargs)
            TITLE=$(gh pr view "$PR" --json title --jq .title)
            HEAD=$(gh pr view "$PR" --json headRefName --jq .headRefName)
            echo "Including PR #$PR â€” $TITLE (branch: $HEAD)"
            git fetch origin "$HEAD"
            git merge --squash "origin/$HEAD"
            git commit -m "Include PR #$PR: $TITLE"
          done

      - name: Push release branch and open PR to main
        env:
          GH_TOKEN: ${{ github.token }}
          BRANCH: ${{ steps.mk.outputs.BRANCH }}
        run: |
          git push -u origin "$BRANCH"
          # If a PR already exists for this head, gh will fail; handle gracefully:
          if gh pr view --head "$BRANCH" --json number >/dev/null 2>&1; then
            echo "PR already exists for $BRANCH"
          else
            gh pr create --base main --head "$BRANCH" \
              --title "Release: $BRANCH" \
              --body "Built from PRs by @${{ steps.form.outputs.GH_USERNAME }} with label \`${{ steps.form.outputs.READY_LABEL }}\` targeting \`${{ steps.form.outputs.BASE }}\`."
          fi
